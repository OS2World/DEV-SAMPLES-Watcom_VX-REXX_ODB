/**/
compiler = CSET
version = 200
dllname = TEST

/*
 * mkmk -- Make the makefiles automatically from all the *.C files in
 *         the C directory.
 */

exports = 'SOMInitModule SOMUninitModule _VXREXX_CALLER_ _' || dllname || '_VERSION_INFO_'
libs    = 'rexx.lib som.lib os2386.lib'

vxodk = value( 'VXODK',, 'OS2ENVIRONMENT' )
if( vxodk = '' )then do
    say "Please set the VXODK environment variable.  It should point to"
    say "the directory where the VX-REXX ODK is installed, as in:"
    say "      SET VXODK=C:\VXODK"
    exit 32000
end

toolkit = value( 'TOOLKIT',, 'OS2ENVIRONMENT' )
if( toolkit = '' )then do
    say "Please set the TOOLKIT environment variable.  It should point to"
    say "the directory where the OS/2 Toolkit is installed, as in:"
    say "      SET TOOLKIT=C:\TOOLKT20"
    say "You may use either the 2.0 or 2.1 toolkit."
    exit 32000
end

if( right( vxodk, 1 ) \= '\' )then do
    vxodk = vxodk || '\'
end

say 'Making sure class information is up-to-date...'

old = directory()
call directory 'som'
call make
call directory old

say 'Building makefile for use with the' compiler 'compiler...'

makefile = 'makefile'
linkfile = dllname || '.LNK'  /* only for CSET */
deffile  = dllname || '.DEF'  /* only for CSET */

compiler = translate( compiler )
if( left( compiler, 1 ) = 'W' )then 
    compiler = 'WATCOM'
else
    compiler = 'CSET'

version = translate( version )
if( left( version, 1 ) = '1' )then
    version = '101'
else
    version = '200'

call rxfuncadd 'sysloadfuncs', 'REXXUTIL', 'SysLoadFuncs'
call sysloadfuncs

call Erase makefile

if( compiler = 'CSET' )then
    call Erase linkfile

call lineout makefile, '#'
call lineout makefile, '# This makefile is automatically generated by mkmk.cmd'
call lineout makefile, '# Don''t edit it manually!'
call lineout makefile, '#'
call lineout makefile, ''
call lineout makefile, 'ODKDIR  =' vxodk || '    '
call lineout makefile, 'SOMDIR  =' vxodk || 'SOM.' || version || '\' || '    '
call lineout makefile, 'dllname =' dllname || '   '
call lineout makefile, ''

if( compiler = 'WATCOM' )then do
    call lineout makefile, 'objs = &'
end; else do
    call lineout makefile, 'objs = \'
end

call sysfiletree 'SOM\SC\*.PRP', 'files', 'fo'
prplist = ''
do i = 1 to files.0
    name = filespec( 'name', files.i )
    prplist = prplist || ' som\sc\' || name
end

call sysfiletree 'C\*.C', 'files', 'fo'
do i = 1 to files.0
    name = filespec( 'name', files.i )
    name = left( name, length( name ) - 2 )
    files.i = name

    if( compiler = 'WATCOM' )then do
        call lineout makefile, '   ' name || '.obj &'
    end; else do
        call lineout makefile, '    $(o)\' || name || '.obj \'

        str = name || '.obj'
        if( i < files.0 )then do
            str = str || ' +'
        end
        call lineout linkfile, str
    end
end

call lineout makefile, ''
call lineout makefile, '!include makefile.inc'
call lineout makefile, ''

if( compiler = 'WATCOM' )then do
    call WatcomOut
    say "Done. Type 'wmake' to compile."
end; else do
    call CSetOut
    say "Done. Type 'nmake' to compile."
end

exit 0

CSetOut:
    call lineout makefile, '$(o)\$(dllname).dll : $(objs) $(o)\$(dllname).res $(dllname).lnk $(dllname).def'
    call lineout makefile, '    cd $(o)'
    call lineout makefile, '    set LIB=$(ODKDIR)lib;$(LIB)'
    call lineout makefile, '    link386 $(lflags) @..\$(dllname).lnk'
    call lineout makefile, '    rc $(dllname).res $(dllname).dll'
    call lineout makefile, '    cd ..'

    say 'Building LNK file ...'

    call lineout linkfile, dllname || '.DLL'
    call lineout linkfile, dllname || '.MAP'
    call lineout linkfile, 'vxrexxc.lib' libs
    call lineout linkfile, '..\' || dllname || '.DEF'

    if( stream( deffile, 'c', 'query exists' ) = '' )then do
        say 'Building DEF file ...'

        call lineout deffile, '; DEF file for' dllname
        call lineout deffile, 'library' dllname 'initinstance terminstance'
        call lineout deffile, 'data multiple readwrite preload nonshared'
        call lineout deffile, 'code loadoncall'
        call lineout deffile, 'protmode'
        call lineout deffile, 'exports'
        do i = 1 to words( exports )
            call lineout deffile, '   ' word( exports, i )
        end
    end

    call lineout makefile, ''
    call lineout makefile, '$(o)\props.obj : c\props.c' prplist
    call lineout makefile, ''

    return

WatcomOut:
    
    call lineout makefile, 'exports =' exports
    call lineout makefile, ''
    call lineout makefile, '$(obj_dir)\$(dllname).dll : $(objs) $(obj_dir)\$(dllname).lnk $(obj_dir)\$(dllname).res'
    call lineout makefile, '    @cd $(obj_dir)'
    call lineout makefile, '    $(std_link) @$(dllname)'
    call lineout makefile, '    rc -p -x $(dllname).res $(dllname).dll > nul'
    call lineout makefile, '    @cd $(main_dir)'
    call lineout makefile, ''
    call lineout makefile, '$(obj_dir)\$(dllname).res : $(rc_dir)\$(dllname).rc'
    call lineout makefile, '    @cd $(rc_dir)'
    call lineout makefile, '    rc -r $[*.rc $(obj_dir)\$[&.res'
    call lineout makefile, '    @cd $(main_dir)'
    call lineout makefile, ''
    call lineout makefile, '$(obj_dir)\$(dllname).lnk : makefile $(locallibs)'
    call lineout makefile, '    %create $@'
    call lineout makefile, '    @%append $@ system os2v2 dll initinstance terminstance'
    call lineout makefile, '    @%append $@ option Quiet,Map,CaseExact,ManyAutoData'
    call lineout makefile, '    @%append $@ option symfile=$(dllname).sym'
    call lineout makefile, '    @%append $@ name $(dllname)'
    call lineout makefile, '    @%append $@ debug all'
    call lineout makefile, '    @for %i in ($(objs)) do @%append $^@ file %i'
    call lineout makefile, '    @for %i in ($(locallibs)) do @%append $^@ library %i'
    call lineout makefile, '    @for %i in ($(libs)) do @%append $^@ library %i'
    call lineout makefile, '    @for %i in ($(exports)) do @%append $^@ export %i'
    call lineout makefile, ''
    call lineout makefile, 'props.obj : c\props.c' prplist
    call lineout makefile, ''
    call lineout makefile, ''
    
    return

Erase:
    file = arg(1)
    if( stream( file, 'c', 'query exists' ) \= '' )then do
        address cmd '@del' file
    end
    return
